{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///talk-to-me-minified.js","webpack:///webpack/bootstrap 07b057b3c77f99d33497","webpack:///./js/talk-to-me.js","webpack:///./js/combine.js","webpack:///./js/talk-to-me-matcher.js","webpack:///./js/talk-to-me-conversate.js","webpack:///./js/talk-to-me-base.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","TalkToMe","options","Talk","defineProperty","_combine","_talkToMeMatcher","_talkToMeConversate","_talkToMeBase","_Combine","getPrototypeOf","Combine","TalkToMeBase","Matcher","Conversate","target","fns","arguments","length","undefined","protoCopy","assign","extendedProto","Array","isArray","reduce","proto","fn","getOwnPropertyNames","forEach","prop","hasOwnProperty","_typeof","Symbol","iterator","obj","_createClass","defineProperties","props","descriptor","key","protoProps","staticProps","hasFoundMatch","createSearches","onResultCallback","resultMatcher","evt","isFinalResult","getFirstMatchOnly","resetFindMatches","findMatches","off","searchForThese","emptyResults","on","addToSearch","records","searches","keys","search","createSearchObject","regex","lastIndexOf","RegExp","term","results","callback","callbackUsed","findMatch","noMatchFound","searchText","fireResults","match","filter","result","transcript","concat","_this","_searchForThese$key","_searchForThese$key2","_results","_this2","noMatch","throwWarning","bind","onNoMatch","matches","defaultNoSupportMessage","nonCompatibleSpeechRecognitionEventError","eventListenerNotFoundError","noSpeechDetected","resultCallback","defaultNoSupportFunction","alert","isCompatibleSpeechRecognitionEvent","speechEvents","indexOf","onEnd","autoRestart","isListening","start","addEventListeners","eventListeners","listener","handler","speech","addEventListener","onError","e","error","console","warn","onResult","isFinal","slice","boundCallback","_TalkToMeBase$getSpee","getSpeechRecogniserConstructor","support","numOfAlternativeMatches","language","finalResultsOnly","maxAlternatives","interimResults","lang","end","audioend","audiostart","nomatch","soundend","soundstart","speechend","speechstart","cb","abort","push","indexOfCallback","ioc","callbacks","removeEventListener","splice","_TalkToMeBase$getSpee2","msg","window","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition"],"mappings":"CAAA,SAAAA,EAAAC,GACA,mBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,QACA,sBAAAG,gBAAAC,IACAD,UAAAH,OACA,CACA,GAAAK,GAAAL,GACA,QAAAM,KAAAD,IAAA,gBAAAJ,iBAAAF,GAAAO,GAAAD,EAAAC,KAECC,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,QAAA,EAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAGAR,EAAA,KDgBM,SAASP,EAAQD,EAASQ,GAE/B,YAeA,SAASS,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMT,GAAQ,IAAKS,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOV,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BS,EAAPT,EAElO,QAASW,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GEhE3d,QAASW,GAASC,GACxB,MAAO,IAAIC,GAAKD,GF8ChBV,OAAOY,eAAexC,EAAS,cAC9B+B,OAAO,IAER/B,EElDeqC,UAXhB,IAAAI,GAAAjC,EAAA,GACAkC,EAAAlC,EAAA,GACAmC,EAAAnC,EAAA,GACAoC,EAAApC,EAAA,GAEM+B,EFwEM,SAAUM,GEvErB,QAAAN,GAAYD,GAAS,MAAArB,GAAAX,KAAAiC,GAAAlB,EAAAf,KAAAsB,OAAAkB,eAAAP,GAAA1B,KAAAP,KACdgC,IF+EN,MARAd,GAAUe,EAAMM,GAQTN,IEjFU,EAAAE,EAAAM,SAAAH,EAAAI,cAAsBN,EAAAO,QAAAN,EAAAO,eF0FnC,SAASjD,EAAQD,GAEtB,YGjGM,SAAS+C,GAAQI,GAAkB,GAAVC,GAAUC,UAAAC,QAAA,GAAAC,SAAAF,UAAA,MAAAA,UAAA,GAGrCG,EAAY5B,OAAO6B,OAAON,EAAOxB,WAGjC+B,GAAiBC,MAAMC,QAAQR,GAAOA,GAAOA,IAAMS,OAAO,SAACC,EAAOC,GAMrE,MALAnC,QAAOoC,oBAAoBD,EAAGpC,WAAWsC,QAAQ,SAAAC,GAC3CV,EAAUW,eAAeD,KAC7BJ,EAAMI,GAAQH,EAAGpC,UAAUuC,MAGtBJ,GACLN,EAIH,OADAL,GAAOxB,UAAYC,OAAO6B,OAAOC,GAC1BP,EHkFPvB,OAAOY,eAAexC,EAAS,cAC9B+B,OAAO,IAER/B,EGtGe+C,WH+HV,SAAS9C,EAAQD,GAEtB,YAUA,SAASiB,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCARhHQ,OAAOY,eAAexC,EAAS,cAC9B+B,OAAO,GAGR,IAAIqC,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIzC,cAAgBuC,OAAS,eAAkBE,IAEtOC,EAAe,WAAc,QAASC,GAAiBtB,EAAQuB,GAAS,IAAK,GAAIrE,GAAI,EAAGA,EAAIqE,EAAMpB,OAAQjD,IAAK,CAAE,GAAIsE,GAAaD,EAAMrE,EAAIsE,GAAW3C,WAAa2C,EAAW3C,aAAc,EAAO2C,EAAWzC,cAAe,EAAU,SAAWyC,KAAYA,EAAW1C,UAAW,GAAML,OAAOY,eAAeW,EAAQwB,EAAWC,IAAKD,IAAiB,MAAO,UAAUxD,EAAa0D,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBtD,EAAYQ,UAAWkD,GAAiBC,GAAaL,EAAiBtD,EAAa2D,GAAqB3D,MIzI7hB4D,GAAgB,EAChBC,EAAA,OACAC,EAAA,OAGEC,EAAgB,SAASC,GAENA,EAAlBC,aAEDL,IAAkBzE,KAAK+E,kBAGpBN,GACPO,EAAiBzE,KAAKP,MAHtBiF,EAAY1E,KAAKP,KAAM6E,IASnBG,EAAmB,WAExBhF,KAAKkF,IAAI,SAAUP,GACnB3E,KAAKmF,eAAiBC,EAAa7E,KAAKP,MACxCyE,GAAgB,EAChBzE,KAAKqF,GAAG,SAAUV,IAKbW,EAAc,WAEnB,GAAIC,KACJ,OAAO,UAAAC,GAMN,MALAlE,QAAOmE,KAAKD,GAAU7B,QAAQ,SAAA+B,GACzBH,EAAQG,KACXH,EAAQG,GAAUC,EAAmBH,EAAUE,MAG1CH,IAMHI,EAAqB,SAASH,EAAUE,GAE7C,GAAIE,GAAQF,EAAOG,YAAY,OAASH,EAAO1C,OAAS,EAAI0C,EAAYA,EAA5D,IAGZ,OAFAE,GAAQ,GAAIE,QAAJ,GAAcF,EAAS,MAG9BG,KAAOL,EACPM,WACAC,SAAWT,EAASE,GACpBQ,cAAe,EACfN,MAAQA,IAMJX,EAAc,SAASJ,GAAK,GAElBC,IAAkBD,EAA3BmB,QAA2BnB,EAAlBC,cAEXL,IAAkBzE,KAAK+E,mBAC1BoB,EAAU5F,KAAKP,KAAM6E,GAGnBC,IACCL,EACFO,EAAiBzE,KAAKP,MAGtBA,KAAKoG,iBAOFD,EAAY,SAAStB,GAE1B7E,KAAKmF,eAAiB7D,OAAO6B,UAAWkD,EAAW9F,KAAKP,KAAM6E,IAC9DyB,EAAY/F,KAAKP,KAAM6E,EAAIC,gBAKtBuB,EAAa,SAASxB,GAE3B,MAAOvD,QAAOmE,KAAKzF,KAAKmF,gBAAgB5B,OAAO,SAACyC,EAAS1B,GAExD,GAAIiC,GAAQ1B,EAAImB,QAAQQ,OAAO,SAAAC,GAC9B,MAAOA,GAAOC,WAAWH,MAAMP,EAAQ1B,GAAKsB,QAQ7C,OALGW,GAAMvD,SACRgD,EAAQ1B,GAAK0B,QAAUA,EAAQ1B,GAAK0B,QAAQW,OAAOJ,EAAM,IACzD9B,GAAgB,GAGVuB,GAELhG,KAAKmF,iBAKHmB,EAAc,SAASxB,GAAe,GAAA8B,GAAA5G,IAE3CsB,QAAOmE,KAAKzF,KAAKmF,gBAAgBxB,QAAQ,SAAAW,GAAO,GAAAuC,GAEfD,EAAKzB,eAAeb,GAA9C0B,EAFyCa,EAEzCb,QAASE,EAFgCW,EAEhCX,YAEf,IAAGF,EAAQhD,SAAWkD,EAAc,IAAAY,GAEXF,EAAKzB,eAAeb,GAAtCyB,EAF6Be,EAE7Bf,KAAMgB,EAFuBD,EAEvBd,OAEZY,GAAKzB,eAAeb,GAAK4B,cAAe,EACxCU,EAAKzB,eAAeb,GAAK2B,SAAS1F,KAAlCqG,GACCb,OACAC,QAAAe,EACAjC,sBAUEM,EAAe,WAAW,GAAA4B,GAAAhH,IAE/B,OAAOsB,QAAOmE,KAAKzF,KAAKmF,gBAAgB5B,OAAO,SAAC4B,EAAgBb,GAO/D,MALAa,GAAeb,GAAOhD,OAAO6B,UAAW6D,EAAK7B,eAAeb,IAC3D0B,WACAE,cAAe,IAGTf,QAMH8B,EAAU,WACf,MAAOjH,MAAKkH,aAAa,sCJ2JXxH,GIrIFiD,QJqIoB,WAC/B,QAASA,KACRhC,EAAgBX,KAAM2C,GA6CvB,MA1CAuB,GAAavB,IACZ2B,IAAK,QACL7C,MAAO,WI1IY,GAAf+D,GAAezC,UAAAC,QAAA,GAAAC,SAAAF,UAAA,MAAAA,UAAA,EAEpB,OAAuB,YAApB,mBAAOyC,GAAP,YAAA1B,EAAO0B,KAA0BlE,OAAOmE,KAAKD,GAAUxC,QAStDhD,KAAKmF,iBACRT,EAAiBY,IACjBX,EAAmBC,EAAcuC,KAAKnH,MACtCA,KAAKqF,GAAG,SAAUV,IAGnB3E,KAAKmF,eAAiBT,EAAec,QAGjCxF,KAAKoG,cACRpG,KAAKoH,cAlBEpH,KAAKkH,aAAa,oEJkKzB5C,IAAK,YACL7C,MAAO,WI7IqB,GAApBwE,GAAoBlD,UAAAC,QAAA,GAAAC,SAAAF,UAAA,GAATkE,EAASlE,UAAA,EAC7B/C,MAAKoG,aAAeH,EAASkB,KAAKnH,SJkJjCsE,IAAK,kBACL7C,MAAO,SIhJOsE,SACR/F,MAAKmF,eAAeY,OJoJpBpD,MAKH,SAAShD,EAAQD,GAEtB,YAQA,SAASiB,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHQ,OAAOY,eAAexC,EAAS,cAC9B+B,OAAO,GAGR,IAAIyC,GAAe,WAAc,QAASC,GAAiBtB,EAAQuB,GAAS,IAAK,GAAIrE,GAAI,EAAGA,EAAIqE,EAAMpB,OAAQjD,IAAK,CAAE,GAAIsE,GAAaD,EAAMrE,EAAIsE,GAAW3C,WAAa2C,EAAW3C,aAAc,EAAO2C,EAAWzC,cAAe,EAAU,SAAWyC,KAAYA,EAAW1C,UAAW,GAAML,OAAOY,eAAeW,EAAQwB,EAAWC,IAAKD,IAAiB,MAAO,UAAUxD,EAAa0D,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBtD,EAAYQ,UAAWkD,GAAiBC,GAAaL,EAAiBtD,EAAa2D,GAAqB3D,KAM/gBnB,GK/WLkD,WL+W0B,WACrC,QAASA,KACRjC,EAAgBX,KAAM4C,GAWvB,MARAsB,GAAatB,IACZ0B,IAAK,aACL7C,MAAO,SKrXE4F,GACVrH,KAAK+E,mBAAoB,EACzB/E,KAAKuG,MAAMc,OLyXJzE,MAmFH,SAASjD,EAAQD,GAEtB,YAQA,SAASiB,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHQ,OAAOY,eAAexC,EAAS,cAC9B+B,OAAO,GAGR,IAAIyC,GAAe,WAAc,QAASC,GAAiBtB,EAAQuB,GAAS,IAAK,GAAIrE,GAAI,EAAGA,EAAIqE,EAAMpB,OAAQjD,IAAK,CAAE,GAAIsE,GAAaD,EAAMrE,EAAIsE,GAAW3C,WAAa2C,EAAW3C,aAAc,EAAO2C,EAAWzC,cAAe,EAAU,SAAWyC,KAAYA,EAAW1C,UAAW,GAAML,OAAOY,eAAeW,EAAQwB,EAAWC,IAAKD,IAAiB,MAAO,UAAUxD,EAAa0D,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBtD,EAAYQ,UAAWkD,GAAiBC,GAAaL,EAAiBtD,EAAa2D,GAAqB3D,MMxd3hByG,EAA0B,wDAC1BC,EAA2C,+DAC3CC,EAA6B,oEAC7BC,EAAmB,4BAGrBC,EAAA,OAEEC,EAA2B,iBAAMC,OAAMN,IAEvCO,EAAqC,SAASC,EAAcjD,GACjE,MAAOvD,QAAOmE,KAAKqC,GAAcC,QAAQlD,OAU7BmD,EAAAtI,EAAAsI,MAAQ,WACpB,GAAGhI,KAAKiI,aAAejI,KAAKkI,YAC3B,MAAOlI,MAAKmI,SAURC,EAAoB,WAAW,GAAAxB,GAAA5G,IAEpCsB,QAAOmE,KAAKzF,KAAKqI,gBAAgB1E,QAAQ,SAAA2E,GACxC,GAAIC,GAAU3B,EAAKyB,eAAeC,GAAU,EACzCC,IACF3B,EAAK4B,OAAOC,iBAAiBH,EAAUC,MAMpCG,EAAU,SAASC,GACxB,GAAG3I,KAAKkI,YAAa,CACpB,GAAe,cAAZS,EAAEC,MAIJ,MAAO5I,MAAKkH,aAAayB,EAAEC,MAH3BC,SAAQC,KAAKrB,KAiBVsB,EAAW,SAASlE,GAAK,GAAAmC,GAAAhH,KAExB8E,EAAgBD,EAAImB,QAAQ,GAAGgD,QAC/BhD,KAAaiD,MAAM1I,KAAKsE,EAAImB,QAAQ,GAE1ChG,MAAKqI,eAAe5B,OAAO9C,QAAQ,SAAC2E,EAAUvI,GACpC,IAANA,GAAWiH,EAAKkB,aAClBI,EAASY,eAAgBpE,gBAAekB,cNievBtG,GM3dPgD,aN2d8B,WMzd1C,QAAAA,KAA0B,GAAdV,GAAce,UAAAC,QAAA,GAAAC,SAAAF,UAAA,MAAAA,UAAA,EAAApC,GAAAX,KAAA0C,EAAA,IAAAyG,GAGCzG,EAAa0G,iCAAjCZ,EAHmBW,EAGnBX,OAAQa,EAHWF,EAGXE,OAGd,IAFArJ,KAAKqJ,QAAUA,GAEZrJ,KAAKqJ,QA0CP,MAAOrJ,MAAKkH,aAAa,8DA1CT,IAQVoC,GAAwDtH,EAAxDsH,wBAAyBC,EAA+BvH,EAA/BuH,SAAUC,EAAqBxH,EAArBwH,gBACzCA,GAA+C,mBAArBA,KAA4CA,EAEtExJ,KAAKwI,OAAS,GAAIA,GAClBxI,KAAKwI,OAAOiB,gBAAkBH,GAA2B,EACzDtJ,KAAKwI,OAAOkB,eAAiBF,EAC7BxJ,KAAKwI,OAAOmB,KAAOJ,GAAY,QAE/BvJ,KAAKkI,aAAc,EACnBlI,KAAKiI,aAAc,EACnBjI,KAAK+E,mBAAoB,EAGzB2C,EAAiBqB,EAAS5B,KAAKnH,MAG/BA,KAAKqI,gBACJF,SACAyB,KAAO5B,EAAMb,KAAKnH,OAClB6J,YACAC,cACAlB,OAASF,EAAQvB,KAAKnH,OACtB+J,WACAtD,QAAUiB,GACVsC,YACAC,cACAC,aACAC,gBAGD/B,EAAkB7H,KAAKP,MNomBxB,MAtHAkE,GAAaxB,IACZ4B,IAAK,cACL7C,MAAO,WMtekC,GAA/B2I,GAA+BrH,UAAAC,QAAA,GAAAC,SAAAF,UAAA,GAA1B4E,EAA0B5E,UAAA,EAC1CqH,QNifC9F,IAAK,QACL7C,MAAO,WMxeRzB,KAAKkI,aAAc,CACnB,KAEC,MADAlI,MAAKwI,OAAOL,SACL,EAER,MAAMQ,GACL,MAAO3I,MAAKkH,aAAayB,ON4ezBrE,IAAK,OACL7C,MAAO,WMxeRzB,KAAKkI,aAAc,EACnBlI,KAAKwI,OAAO6B,WNofX/F,IAAK,KACL7C,MAAO,SM3eNoD,EAAKoB,GACP,IAAG4B,EAAmC7H,KAAKqI,eAAgBxD,GAQ1D,MAAO7E,MAAKkH,aAAaK,EAPzB,IAAI2B,GAAgBjD,EAASkB,KAAKnH,KAAKwI,OAC5B,YAAR3D,GACF7E,KAAKwI,OAAOC,iBAAiB5D,EAAKqE,GAEnClJ,KAAKqI,eAAexD,GAAKyF,MAAOrE,WAAUiD,qBNkgB1C5E,IAAK,MACL7C,MAAO,SM5eLoD,EAAKoB,GACR,IAAG4B,EAAmC7H,KAAKqI,eAAgBxD,GA6B1D,MAAOqC,cAAaK,EA3BpB,IAAIgD,GAAkBvK,KAAKqI,eAAexD,GAAKtB,OAAO,SAACiH,EAAKC,EAAW1K,GAItE,MAHG0K,GAAUxE,WAAaA,IACzBuE,EAAMzK,GAEAyK,MAGR,MAAGD,MAOF,MAAOvK,MAAKkH,aAAaM,EAG1B,IATY,WAAR3C,GACF7E,KAAKwI,OAAOkC,oBAAoB7F,EAAK7E,KAAKqI,eAAexD,GAAK0F,GAAiBrB,eAEhFlJ,KAAKqI,eAAexD,GAAK8F,OAAOJ,EAAiB,GAMvC,WAAR1F,GAA0D,IAAtC7E,KAAKqI,eAAe5B,OAAOzD,OAAc,CAE/DhD,KAAKwI,OAAOkC,oBAAoB,SAAUhD,EAFqB,IAAAkD,GAG9ClI,EAAa0G,iCAAxBZ,EAHyDoC,EAGzDpC,MACNxI,MAAKwI,OAAS,GAAIA,GAClBJ,EAAkB7H,KAAKP,UNsfxBsE,IAAK,eACL7C,MAAO,SM7eIoJ,GAEZ,MADAhC,SAAQC,KAAK+B,IACN,ONgfNvG,IAAK,iCACL7C,MAAO,WM7eR,GAAI+G,GAASsC,OAAOC,mBACnBD,OAAOE,yBACPF,OAAOG,sBACPH,OAAOI,qBACPJ,OAAOK,kBACR,QAAS3C,SAAQa,UAAYb,ON8etB9F","file":"talk-to-me-minified.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/build\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.TalkToMe = TalkToMe;\n\t\n\tvar _combine = __webpack_require__(1);\n\t\n\tvar _talkToMeMatcher = __webpack_require__(2);\n\t\n\tvar _talkToMeConversate = __webpack_require__(3);\n\t\n\tvar _talkToMeBase = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Talk = function (_Combine) {\n\t\t_inherits(Talk, _Combine);\n\t\n\t\tfunction Talk(options) {\n\t\t\t_classCallCheck(this, Talk);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Talk).call(this, options));\n\t\t}\n\t\n\t\treturn Talk;\n\t}((0, _combine.Combine)(_talkToMeBase.TalkToMeBase, [_talkToMeMatcher.Matcher, _talkToMeConversate.Conversate]));\n\t\n\tfunction TalkToMe(options) {\n\t\treturn new Talk(options);\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.Combine = Combine;\n\tfunction Combine(target) {\n\t\tvar fns = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t\n\t\n\t\t// copy super class prototype\n\t\tvar protoCopy = Object.assign(target.prototype);\n\t\n\t\t// copy additional, non-present properties onto super class prototype\n\t\tvar extendedProto = (Array.isArray(fns) ? fns : [fns]).reduce(function (proto, fn) {\n\t\t\tObject.getOwnPropertyNames(fn.prototype).forEach(function (prop) {\n\t\t\t\tif (!protoCopy.hasOwnProperty(prop)) {\n\t\t\t\t\tproto[prop] = fn.prototype[prop];\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn proto;\n\t\t}, protoCopy);\n\t\n\t\t// assign extended prototype to superclass\n\t\ttarget.prototype = Object.assign(extendedProto);\n\t\treturn target;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar hasFoundMatch = false;\n\tvar createSearches = void 0;\n\tvar onResultCallback = void 0;\n\t\n\t// the initial result handler\n\tvar resultMatcher = function resultMatcher(evt) {\n\t\tvar isFinalResult = evt.isFinalResult;\n\t\n\t\n\t\tif (!hasFoundMatch || !this.getFirstMatchOnly) {\n\t\t\tfindMatches.call(this, evt);\n\t\t} else if (hasFoundMatch) {\n\t\t\tresetFindMatches.call(this);\n\t\t}\n\t};\n\t\n\t// will remove the callback and re-initialise the searches\n\tvar resetFindMatches = function resetFindMatches() {\n\t\n\t\tthis.off('result', onResultCallback);\n\t\tthis.searchForThese = emptyResults.call(this);\n\t\thasFoundMatch = false;\n\t\tthis.on('result', onResultCallback);\n\t};\n\t\n\t// returns a function that adds new search terms\n\tvar addToSearch = function addToSearch() {\n\t\n\t\tvar records = {};\n\t\treturn function (searches) {\n\t\t\tObject.keys(searches).forEach(function (search) {\n\t\t\t\tif (!records[search]) {\n\t\t\t\t\trecords[search] = createSearchObject(searches, search);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn records;\n\t\t};\n\t};\n\t\n\t// new search terms are stored as objects\n\tvar createSearchObject = function createSearchObject(searches, search) {\n\t\n\t\tvar regex = search.lastIndexOf('s') === search.length - 1 ? search : search + 's?';\n\t\tregex = new RegExp('' + regex, 'i');\n\t\n\t\treturn {\n\t\t\tterm: search,\n\t\t\tresults: [],\n\t\t\tcallback: searches[search],\n\t\t\tcallbackUsed: false,\n\t\t\tregex: regex\n\t\t};\n\t};\n\t\n\t// handles finding matches and when the last result fires and no matches are found\n\tvar findMatches = function findMatches(evt) {\n\t\tvar results = evt.results;\n\t\tvar isFinalResult = evt.isFinalResult;\n\t\n\t\n\t\tif (!hasFoundMatch || !this.getFirstMatchOnly) {\n\t\t\tfindMatch.call(this, evt);\n\t\t}\n\t\n\t\tif (isFinalResult) {\n\t\t\tif (hasFoundMatch) {\n\t\t\t\tresetFindMatches.call(this);\n\t\t\t} else {\n\t\t\t\tthis.noMatchFound();\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// searches for matches against each stored search item and updates the search objects\n\tvar findMatch = function findMatch(evt) {\n\t\n\t\tthis.searchForThese = Object.assign({}, searchText.call(this, evt));\n\t\tfireResults.call(this, evt.isFinalResult);\n\t};\n\t\n\t// searches for matches and updates search objects if found\n\tvar searchText = function searchText(evt) {\n\t\n\t\treturn Object.keys(this.searchForThese).reduce(function (results, key) {\n\t\n\t\t\tvar match = evt.results.filter(function (result) {\n\t\t\t\treturn result.transcript.match(results[key].regex);\n\t\t\t});\n\t\n\t\t\tif (match.length) {\n\t\t\t\tresults[key].results = results[key].results.concat(match[0]);\n\t\t\t\thasFoundMatch = true;\n\t\t\t}\n\t\n\t\t\treturn results;\n\t\t}, this.searchForThese);\n\t};\n\t\n\t// fires results when a new match has been made\n\tvar fireResults = function fireResults(isFinalResult) {\n\t\tvar _this = this;\n\t\n\t\tObject.keys(this.searchForThese).forEach(function (key) {\n\t\t\tvar _searchForThese$key = _this.searchForThese[key];\n\t\t\tvar results = _searchForThese$key.results;\n\t\t\tvar callbackUsed = _searchForThese$key.callbackUsed;\n\t\n\t\n\t\t\tif (results.length && !callbackUsed) {\n\t\t\t\tvar _searchForThese$key2 = _this.searchForThese[key];\n\t\t\t\tvar term = _searchForThese$key2.term;\n\t\t\t\tvar _results = _searchForThese$key2.results;\n\t\n\t\n\t\t\t\t_this.searchForThese[key].callbackUsed = true;\n\t\t\t\t_this.searchForThese[key].callback.call(_this, {\n\t\t\t\t\tterm: term,\n\t\t\t\t\tresults: _results,\n\t\t\t\t\tisFinalResult: isFinalResult\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\t\n\t// refreshes the search objects upon completion\n\tvar emptyResults = function emptyResults() {\n\t\tvar _this2 = this;\n\t\n\t\treturn Object.keys(this.searchForThese).reduce(function (searchForThese, key) {\n\t\n\t\t\tsearchForThese[key] = Object.assign({}, _this2.searchForThese[key], {\n\t\t\t\tresults: [],\n\t\t\t\tcallbackUsed: false\n\t\t\t});\n\t\n\t\t\treturn searchForThese;\n\t\t}, {});\n\t};\n\t\n\tvar noMatch = function noMatch() {\n\t\treturn this.throwWarning('Sorry no matches found, try again?');\n\t};\n\t\n\t/*\r\n\t\tExpects an object of key (search term) and value (callback)\r\n\t\r\n\t\tCreates an object property on the instance called searchForThese to store the above\r\n\t\r\n\t\tEach time `match` is called it adds to the existing search terms\r\n\t\r\n\t\tAll results are captured in a single handler\r\n\t\r\n\t\tIf a match is yet to be found and events are being produced it will continue to attempt to find matches\r\n\t\r\n\t\tOnce a match is found the callback is fired and the results are stored\r\n\t\r\n\t\tThe callback for a match is only fired once\r\n\t\r\n\t\tIf no matches are found and the Speech Recognition API has finished the no match handler will fire\r\n\t\r\n\t*/\n\t\n\tvar Matcher = exports.Matcher = function () {\n\t\tfunction Matcher() {\n\t\t\t_classCallCheck(this, Matcher);\n\t\t}\n\t\n\t\t_createClass(Matcher, [{\n\t\t\tkey: 'match',\n\t\t\tvalue: function match() {\n\t\t\t\tvar searches = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\n\t\t\t\tif ((typeof searches === 'undefined' ? 'undefined' : _typeof(searches)) !== 'object' || !Object.keys(searches).length) {\n\t\t\t\t\treturn this.throwWarning('match expects an object with a key term and a callback value.');\n\t\t\t\t}\n\t\n\t\t\t\t/*\r\n\t    *\tIf match hasn't been called before add the result callback \r\n\t    *\tand create a cache to use to add new searches to\r\n\t    */\n\t\n\t\t\t\tif (!this.searchForThese) {\n\t\t\t\t\tcreateSearches = addToSearch();\n\t\t\t\t\tonResultCallback = resultMatcher.bind(this);\n\t\t\t\t\tthis.on('result', onResultCallback);\n\t\t\t\t}\n\t\n\t\t\t\tthis.searchForThese = createSearches(searches);\n\t\n\t\t\t\t// set a default on no match found handler\n\t\t\t\tif (!this.noMatchFound) {\n\t\t\t\t\tthis.onNoMatch();\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'onNoMatch',\n\t\t\tvalue: function onNoMatch() {\n\t\t\t\tvar callback = arguments.length <= 0 || arguments[0] === undefined ? noMatch : arguments[0];\n\t\n\t\t\t\tthis.noMatchFound = callback.bind(this);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'removeMatchTerm',\n\t\t\tvalue: function removeMatchTerm(term) {\n\t\t\t\tdelete this.searchForThese[term];\n\t\t\t}\n\t\t}]);\n\n\t\treturn Matcher;\n\t}();\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar conversation = [];\n\t\n\tvar Conversate = exports.Conversate = function () {\n\t\tfunction Conversate() {\n\t\t\t_classCallCheck(this, Conversate);\n\t\t}\n\t\n\t\t_createClass(Conversate, [{\n\t\t\tkey: \"conversate\",\n\t\t\tvalue: function conversate(matches) {\n\t\t\t\tthis.getFirstMatchOnly = false;\n\t\t\t\tthis.match(matches);\n\t\t\t}\n\t\t}]);\n\n\t\treturn Conversate;\n\t}();\n\n\t/*\r\n\r\n\tvar answers = {\r\n\t\t\r\n\t}\r\n\r\n\tvar start = {\r\n\t\tprompt : \"What kind of appliance are you looking for?\",\r\n\t\tlistenFor : [\"washing machine\", \"TV\",\"freezer\"],\r\n\t\tsuccess : next,\r\n\t\tfail : \"Sorry, I didn't understand that. Try again!\",\r\n\t\tfound : false\r\n\t};\r\n\r\n\tvar next = {\r\n\t\tprompt : \"Ok so you're looking for a ${answers[0]}, any particular brand?\",\r\n\t\tlistenFor : [\"hotpoint\",\"sony\",\"samsung\"],\r\n\t\tsuccess : next,\r\n\t\tfail : \"Sorry, I didn't understand that. Try again!\"\r\n\t};\r\n\r\n\tinitiate a conversation\r\n\r\n\t\"what products are you looking for?\"\r\n\r\n\tpossible answers:\r\n\r\n\t\"washing machine\"\r\n\t\"TV\"\r\n\t\"freezer\"\r\n\r\n\treply:\r\n\r\n\t\"Ok so you're interested in a ${answer}.\r\n\tAny particular brand?\"\r\n\r\n\tpossible answers:\r\n\r\n\t\"yes\"\r\n\t\"no\"\r\n\t\"hotpoint\"\r\n\t\"sony\"\r\n\t\"samsung\"\r\n\r\n\r\n\r\n\r\n\r\n\ttop level object\r\n\r\n\t{\r\n\t\tdepth : 1 // the amount of questions\r\n\t\tquestions : [{\r\n\t\t\tquestion : 'What would you like to shop for?',\r\n\t\t\tanswers : {\r\n\t\t\t\tname : ['washing machine', 'TVs']\r\n\t\t\t\tverbs : [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpronoun : 'you',\r\n\t\t\t\t\t\tverb : 'show'\r\n\t\t\t\t\t}, \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpronoun : 'you',\r\n\t\t\t\t\t\tverb : ['info', 'information']\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tonMatch : function(evt) {\r\n\t\t\t\t\tconsole.log('Do you want us to ${verb} ${pronoun} ${results} or ')\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}]\r\n\t}\r\n\r\n\r\n\r\n\r\n\t*/\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// default error messages\n\tvar defaultNoSupportMessage = 'Sorry your browser doesn\\'t support speech recognition';\n\tvar nonCompatibleSpeechRecognitionEventError = 'Sorry the speech recognition API does not support this event';\n\tvar eventListenerNotFoundError = 'Sorry the listener you\\'re trying to remove isn\\'t currently active';\n\tvar noSpeechDetected = 'Sorry no speech detected!';\n\t\n\t// a reference to the bound result handler so it can be removed\n\tvar resultCallback = void 0;\n\t\n\tvar defaultNoSupportFunction = function defaultNoSupportFunction() {\n\t\treturn alert(defaultNoSupportMessage);\n\t};\n\t\n\tvar isCompatibleSpeechRecognitionEvent = function isCompatibleSpeechRecognitionEvent(speechEvents, evt) {\n\t\treturn Object.keys(speechEvents).indexOf(evt) > -1;\n\t};\n\t\n\t/*\r\n\t *\tFires after each result has finished being analysed\r\n\t *\tSet the autoRestart property to true so it continues to listen\r\n\t *\totherwise you'll have to manually use the start method to begin listening again\t\r\n\t */\n\t\n\tvar onEnd = exports.onEnd = function onEnd() {\n\t\tif (this.autoRestart && this.isListening) {\n\t\t\treturn this.start();\n\t\t}\n\t};\n\t\n\t/*\r\n\t *\tCycles through the event listeners stored and adds them to the instance\r\n\t *\tof the speech recognition constructor used at the heart of Talk To Me\r\n\t */\n\t\n\tvar addEventListeners = function addEventListeners() {\n\t\tvar _this = this;\n\t\n\t\tObject.keys(this.eventListeners).forEach(function (listener) {\n\t\t\tvar handler = _this.eventListeners[listener][0];\n\t\t\tif (handler) {\n\t\t\t\t_this.speech.addEventListener(listener, handler);\n\t\t\t}\n\t\t});\n\t};\n\t\n\tvar onError = function onError(e) {\n\t\tif (this.isListening) {\n\t\t\tif (e.error === 'no-speech') {\n\t\t\t\tconsole.warn(noSpeechDetected);\n\t\t\t} else {\n\t\t\t\treturn this.throwWarning(e.error);\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/*\r\n\t *\tThe ONLY result event listener added to the speech recognition instance\r\n\t *\tThis is because the event object the native API spits out is heavily modified\r\n\t *\tand stripped down to just the results and whether it's the last set of results\r\n\t *\tThis stripped down event object is then passed into each registered result callback\r\n\t *\twhich is bound so its context is the current instance of Talk To Me\r\n\t */\n\t\n\tvar onResult = function onResult(evt) {\n\t\tvar _this2 = this;\n\t\n\t\tvar isFinalResult = evt.results[0].isFinal;\n\t\tvar results = [].slice.call(evt.results[0]);\n\t\n\t\tthis.eventListeners.result.forEach(function (listener, i) {\n\t\t\tif (i !== 0 && _this2.isListening) {\n\t\t\t\tlistener.boundCallback({ isFinalResult: isFinalResult, results: results });\n\t\t\t}\n\t\t});\n\t};\n\t\n\tvar TalkToMeBase = exports.TalkToMeBase = function () {\n\t\tfunction TalkToMeBase() {\n\t\t\tvar options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t\t_classCallCheck(this, TalkToMeBase);\n\t\n\t\t\t// get the speech recognition constructor and test for support\n\t\n\t\t\tvar _TalkToMeBase$getSpee = TalkToMeBase.getSpeechRecogniserConstructor();\n\t\n\t\t\tvar speech = _TalkToMeBase$getSpee.speech;\n\t\t\tvar support = _TalkToMeBase$getSpee.support;\n\t\n\t\t\tthis.support = support;\n\t\n\t\t\tif (this.support) {\n\t\n\t\t\t\t/*\r\n\t    *\tDefault options (optional)\r\n\t    *\tSet against the instance of the speech recognition API\r\n\t    *\tAnd the instance of Talk To Me\r\n\t    */\n\t\n\t\t\t\tvar numOfAlternativeMatches = options.numOfAlternativeMatches;\n\t\t\t\tvar language = options.language;\n\t\t\t\tvar finalResultsOnly = options.finalResultsOnly;\n\t\n\t\t\t\tfinalResultsOnly = typeof finalResultsOnly === 'undefined' ? false : !finalResultsOnly;\n\t\n\t\t\t\tthis.speech = new speech();\n\t\t\t\tthis.speech.maxAlternatives = numOfAlternativeMatches || 5;\n\t\t\t\tthis.speech.interimResults = finalResultsOnly;\n\t\t\t\tthis.speech.lang = language || 'en-US';\n\t\n\t\t\t\tthis.isListening = false;\n\t\t\t\tthis.autoRestart = false;\n\t\t\t\tthis.getFirstMatchOnly = true;\n\t\n\t\t\t\t// store a reference to the bound result callback\n\t\t\t\tresultCallback = onResult.bind(this);\n\t\n\t\t\t\t// default event listeners\n\t\t\t\tthis.eventListeners = {\n\t\t\t\t\tstart: [],\n\t\t\t\t\tend: [onEnd.bind(this)],\n\t\t\t\t\taudioend: [],\n\t\t\t\t\taudiostart: [],\n\t\t\t\t\terror: [onError.bind(this)],\n\t\t\t\t\tnomatch: [],\n\t\t\t\t\tresult: [resultCallback],\n\t\t\t\t\tsoundend: [],\n\t\t\t\t\tsoundstart: [],\n\t\t\t\t\tspeechend: [],\n\t\t\t\t\tspeechstart: []\n\t\t\t\t};\n\t\n\t\t\t\taddEventListeners.call(this);\n\t\t\t} else {\n\t\t\t\treturn this.throwWarning('Sorry, no speech recognition ability found in this browser.');\n\t\t\t}\n\t\t}\n\t\n\t\t// modify the on no support handler\n\t\n\t\n\t\t_createClass(TalkToMeBase, [{\n\t\t\tkey: 'onNoSupport',\n\t\t\tvalue: function onNoSupport() {\n\t\t\t\tvar cb = arguments.length <= 0 || arguments[0] === undefined ? defaultNoSupportFunction : arguments[0];\n\t\n\t\t\t\tcb();\n\t\t\t}\n\t\n\t\t\t/*\r\n\t   *\tTry / catch will prevent errors thrown if start is called when the\r\n\t   *\tspeech recognition API has already started to listen\r\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'start',\n\t\t\tvalue: function start() {\n\t\t\t\tthis.isListening = true;\n\t\t\t\ttry {\n\t\t\t\t\tthis.speech.start();\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn this.throwWarning(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'stop',\n\t\t\tvalue: function stop() {\n\t\t\t\tthis.isListening = false;\n\t\t\t\tthis.speech.abort();\n\t\t\t}\n\t\n\t\t\t/*\r\n\t   *\tAdd event listeners to the instance of the speech recognition API \r\n\t   *\tStores a reference to the callback and the bound callback (binds the instance of Talk To Me to it)\r\n\t   *\tNote: It will not allow more than one 'result' handler because of the way Talk To Me\r\n\t   *\tmodifies the result event object and passes it into the registered callbacks\r\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'on',\n\t\t\tvalue: function on(evt, callback) {\n\t\t\t\tif (isCompatibleSpeechRecognitionEvent(this.eventListeners, evt)) {\n\t\t\t\t\tvar boundCallback = callback.bind(this.speech);\n\t\t\t\t\tif (evt !== 'result') {\n\t\t\t\t\t\tthis.speech.addEventListener(evt, boundCallback);\n\t\t\t\t\t}\n\t\t\t\t\tthis.eventListeners[evt].push({ callback: callback, boundCallback: boundCallback });\n\t\t\t\t} else {\n\t\t\t\t\treturn this.throwWarning(nonCompatibleSpeechRecognitionEventError);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/*\r\n\t   *\tRemoves event listeners from the instance of the speech recognition API \r\n\t   *\tMatches the callback, not the bound one as externally there is no reference to it\r\n\t   *\tThen removes the bound callback counterpart event listener\r\n\t   *\r\n\t   *\tNote: if the penultimate result event listener is removed, Talk To Me's result listener\r\n\t   *\tis also removed, the instance of the speech recognition API is destroyed and a new one created \r\n\t   *\tand the event listeners are re-registered\r\n\t   *\r\n\t   *\tThis is specifically designed for the (additional) Matcher module (it won't affect the base class)\r\n\t   *\tThe Matcher module will only ever register one additional result handler \r\n\t   *\tand consolidates all searches into a single callback. If it is set to find just the first match \r\n\t   *\tit will fire the callback and destroy the instance of the speech recognition API \r\n\t   *\tto prevent remaining result events from firing\r\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'off',\n\t\t\tvalue: function off(evt, callback) {\n\t\t\t\tif (isCompatibleSpeechRecognitionEvent(this.eventListeners, evt)) {\n\t\n\t\t\t\t\tvar indexOfCallback = this.eventListeners[evt].reduce(function (ioc, callbacks, i) {\n\t\t\t\t\t\tif (callbacks.callback === callback) {\n\t\t\t\t\t\t\tioc = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ioc;\n\t\t\t\t\t}, -1);\n\t\n\t\t\t\t\tif (indexOfCallback > -1) {\n\t\t\t\t\t\tif (evt !== 'result') {\n\t\t\t\t\t\t\tthis.speech.removeEventListener(evt, this.eventListeners[evt][indexOfCallback].boundCallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.eventListeners[evt].splice(indexOfCallback, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.throwWarning(eventListenerNotFoundError);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (evt === 'result' && this.eventListeners.result.length === 1) {\n\t\n\t\t\t\t\t\tthis.speech.removeEventListener('result', resultCallback);\n\t\n\t\t\t\t\t\tvar _TalkToMeBase$getSpee2 = TalkToMeBase.getSpeechRecogniserConstructor();\n\t\n\t\t\t\t\t\tvar speech = _TalkToMeBase$getSpee2.speech;\n\t\n\t\t\t\t\t\tthis.speech = new speech();\n\t\t\t\t\t\taddEventListeners.call(this);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn throwWarning(nonCompatibleSpeechRecognitionEventError);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'throwWarning',\n\t\t\tvalue: function throwWarning(msg) {\n\t\t\t\tconsole.warn(msg);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'getSpeechRecogniserConstructor',\n\t\t\tvalue: function getSpeechRecogniserConstructor() {\n\t\t\t\tvar speech = window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition;\n\t\t\t\treturn { speech: speech, support: !!speech };\n\t\t\t}\n\t\t}]);\n\n\t\treturn TalkToMeBase;\n\t}();\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** talk-to-me-minified.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 07b057b3c77f99d33497\n **/","import { Combine } from './combine';\r\nimport { Matcher } from './talk-to-me-matcher';\r\nimport { Conversate } from './talk-to-me-conversate';\r\nimport { TalkToMeBase } from './talk-to-me-base';\r\n\r\nclass Talk extends Combine(TalkToMeBase, [Matcher, Conversate]) {\r\n\tconstructor(options) {\r\n\t\tsuper(options);\r\n\t}\r\n}\r\n\r\nexport function TalkToMe(options) {\r\n\treturn new Talk(options);\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./js/talk-to-me.js\n **/","export function Combine(target, fns = []) {\r\n\r\n\t// copy super class prototype\r\n\tlet protoCopy = Object.assign(target.prototype);\r\n\r\n\t// copy additional, non-present properties onto super class prototype\r\n\tlet extendedProto = (Array.isArray(fns) ? fns : [fns]).reduce((proto, fn) => {\r\n\t\tObject.getOwnPropertyNames(fn.prototype).forEach(prop => {\r\n\t\t\tif(!(protoCopy.hasOwnProperty(prop))) {\r\n\t\t\t\tproto[prop] = fn.prototype[prop];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn proto; \r\n\t}, protoCopy);\r\n\r\n\t// assign extended prototype to superclass\r\n\ttarget.prototype = Object.assign(extendedProto);\r\n\treturn target;\r\n\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./js/combine.js\n **/","let hasFoundMatch = false;\r\nlet createSearches;\r\nlet onResultCallback;\r\n\r\n// the initial result handler\r\nconst resultMatcher = function(evt) {\r\n\r\n\tlet { isFinalResult } = evt;\r\n\r\n\tif (!hasFoundMatch || !this.getFirstMatchOnly) {\r\n\t\tfindMatches.call(this, evt);\r\n\t}\t\r\n\telse if(hasFoundMatch) {\r\n\t\tresetFindMatches.call(this);\r\n\t}\r\n\t\r\n};\r\n\r\n// will remove the callback and re-initialise the searches\r\nconst resetFindMatches = function() {\r\n\r\n\tthis.off('result', onResultCallback);\r\n\tthis.searchForThese = emptyResults.call(this);\t\r\n\thasFoundMatch = false;\r\n\tthis.on('result', onResultCallback);\t\r\n\r\n};\r\n\r\n// returns a function that adds new search terms\r\nconst addToSearch = function() {\r\n\r\n\tlet records = {};\r\n\treturn searches => {\r\n\t\tObject.keys(searches).forEach(search => {\r\n\t\t\tif(!records[search]) {\r\n\t\t\t\trecords[search] = createSearchObject(searches, search);\r\n\t\t\t}\r\n\t\t});\t\t\r\n\t\treturn records;\r\n\t}\r\n\r\n};\r\n\r\n// new search terms are stored as objects\r\nconst createSearchObject = function(searches, search) {\r\n\r\n\tlet regex = search.lastIndexOf('s') === search.length - 1 ? search : `${search}s?`;\r\n\tregex = new RegExp(`${regex}`, 'i');\r\n\r\n\treturn {\r\n\t\tterm : search,\r\n\t\tresults : [],\r\n\t\tcallback : searches[search],\r\n\t\tcallbackUsed : false,\r\n\t\tregex : regex\r\n\t};\r\n\r\n};\r\n\r\n// handles finding matches and when the last result fires and no matches are found\r\nconst findMatches = function(evt) {\r\n\r\n\tlet { results, isFinalResult } = evt;\r\n\r\n\tif(!hasFoundMatch || !this.getFirstMatchOnly) {\r\n\t\tfindMatch.call(this, evt);\r\n\t}\r\n\r\n\tif(isFinalResult) {\r\n\t\tif(hasFoundMatch) {\r\n\t\t\tresetFindMatches.call(this);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.noMatchFound();\r\n\t\t}\t\t\r\n\t}\r\n\r\n};\r\n\r\n// searches for matches against each stored search item and updates the search objects\r\nconst findMatch = function(evt) {\r\n\t\r\n\tthis.searchForThese = Object.assign({}, searchText.call(this, evt));\r\n\tfireResults.call(this, evt.isFinalResult);\t\r\n\r\n};\r\n\r\n// searches for matches and updates search objects if found\r\nconst searchText = function(evt) {\r\n\r\n\treturn Object.keys(this.searchForThese).reduce((results, key) => {\r\n\r\n\t\tlet match = evt.results.filter(result => {\r\n\t\t\treturn result.transcript.match(results[key].regex);\r\n\t\t});\r\n\r\n\t\tif(match.length) {\r\n\t\t\tresults[key].results = results[key].results.concat(match[0]);\r\n\t\t\thasFoundMatch = true;\r\n\t\t}\t\r\n\r\n\t\treturn results;\r\n\r\n\t}, this.searchForThese);\r\n\r\n};\r\n\r\n// fires results when a new match has been made\r\nconst fireResults = function(isFinalResult) {\r\n\r\n\tObject.keys(this.searchForThese).forEach(key => {\r\n\r\n\t\tlet { results, callbackUsed } = this.searchForThese[key];\r\n\r\n\t\tif(results.length && !callbackUsed) {\r\n\r\n\t\t\tlet { term, results } = this.searchForThese[key];\r\n\r\n\t\t\tthis.searchForThese[key].callbackUsed = true;\r\n\t\t\tthis.searchForThese[key].callback.call(this, { \r\n\t\t\t\tterm, \r\n\t\t\t\tresults, \r\n\t\t\t\tisFinalResult\r\n\t\t\t});\t\t\t\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n};\r\n\r\n// refreshes the search objects upon completion\r\nconst emptyResults = function() {\r\n\r\n\treturn Object.keys(this.searchForThese).reduce((searchForThese, key) => {\r\n\r\n\t\tsearchForThese[key] = Object.assign({}, this.searchForThese[key], {\r\n\t\t\tresults : [],\r\n\t\t\tcallbackUsed : false\r\n\t\t});\r\n\r\n\t\treturn searchForThese;\r\n\r\n\t}, {});\r\n\r\n};\r\n\r\nconst noMatch = function() {\r\n\treturn this.throwWarning('Sorry no matches found, try again?');\r\n}; \r\n\r\n/*\r\n\tExpects an object of key (search term) and value (callback)\r\n\r\n\tCreates an object property on the instance called searchForThese to store the above\r\n\r\n\tEach time `match` is called it adds to the existing search terms\r\n\r\n\tAll results are captured in a single handler\r\n\r\n\tIf a match is yet to be found and events are being produced it will continue to attempt to find matches\r\n\r\n\tOnce a match is found the callback is fired and the results are stored\r\n\r\n\tThe callback for a match is only fired once\r\n\r\n\tIf no matches are found and the Speech Recognition API has finished the no match handler will fire\r\n\r\n*/\r\n\r\nexport class Matcher {\r\n\r\n\tmatch(searches = {}) {\r\n\r\n\t\tif(typeof searches !== 'object' || !Object.keys(searches).length){\r\n\t\t\treturn this.throwWarning('match expects an object with a key term and a callback value.');\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t *\tIf match hasn't been called before add the result callback \r\n\t\t *\tand create a cache to use to add new searches to\r\n\t\t */\r\n\r\n\t\tif(!this.searchForThese) {\r\n\t\t\tcreateSearches = addToSearch();\r\n\t\t\tonResultCallback = resultMatcher.bind(this);\r\n\t\t\tthis.on('result', onResultCallback);\r\n\t\t}\r\n\t\t\r\n\t\tthis.searchForThese = createSearches(searches);\r\n\t\t\r\n\t\t// set a default on no match found handler\r\n\t\tif(!this.noMatchFound) {\r\n\t\t\tthis.onNoMatch();\r\n\t\t}\t\r\n\t}\r\n\r\n\tonNoMatch(callback = noMatch) {\r\n\t\tthis.noMatchFound = callback.bind(this);\r\n\t}\r\n\r\n\tremoveMatchTerm(term) {\r\n\t\tdelete this.searchForThese[term];\t\r\n\t}\r\n\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./js/talk-to-me-matcher.js\n **/","let conversation = [];\r\n\r\nexport class Conversate {\r\n\tconversate(matches) {\r\n\t\tthis.getFirstMatchOnly = false;\r\n\t\tthis.match(matches);\r\n\t}\r\n}\r\n\r\n/*\r\n\r\nvar answers = {\r\n\t\r\n}\r\n\r\nvar start = {\r\n\tprompt : \"What kind of appliance are you looking for?\",\r\n\tlistenFor : [\"washing machine\", \"TV\",\"freezer\"],\r\n\tsuccess : next,\r\n\tfail : \"Sorry, I didn't understand that. Try again!\",\r\n\tfound : false\r\n};\r\n\r\nvar next = {\r\n\tprompt : \"Ok so you're looking for a ${answers[0]}, any particular brand?\",\r\n\tlistenFor : [\"hotpoint\",\"sony\",\"samsung\"],\r\n\tsuccess : next,\r\n\tfail : \"Sorry, I didn't understand that. Try again!\"\r\n};\r\n\r\ninitiate a conversation\r\n\r\n\"what products are you looking for?\"\r\n\r\npossible answers:\r\n\r\n\"washing machine\"\r\n\"TV\"\r\n\"freezer\"\r\n\r\nreply:\r\n\r\n\"Ok so you're interested in a ${answer}.\r\nAny particular brand?\"\r\n\r\npossible answers:\r\n\r\n\"yes\"\r\n\"no\"\r\n\"hotpoint\"\r\n\"sony\"\r\n\"samsung\"\r\n\r\n\r\n\r\n\r\n\r\ntop level object\r\n\r\n{\r\n\tdepth : 1 // the amount of questions\r\n\tquestions : [{\r\n\t\tquestion : 'What would you like to shop for?',\r\n\t\tanswers : {\r\n\t\t\tname : ['washing machine', 'TVs']\r\n\t\t\tverbs : [\r\n\t\t\t\t{\r\n\t\t\t\t\tpronoun : 'you',\r\n\t\t\t\t\tverb : 'show'\r\n\t\t\t\t}, \r\n\t\t\t\t{\r\n\t\t\t\t\tpronoun : 'you',\r\n\t\t\t\t\tverb : ['info', 'information']\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tonMatch : function(evt) {\r\n\t\t\t\tconsole.log('Do you want us to ${verb} ${pronoun} ${results} or ')\t\r\n\t\t\t}\r\n\t\t}\r\n\t}]\r\n}\r\n\r\n\r\n\r\n\r\n*/\n\n\n/** WEBPACK FOOTER **\n ** ./js/talk-to-me-conversate.js\n **/","// default error messages\r\nconst defaultNoSupportMessage = 'Sorry your browser doesn\\'t support speech recognition';\r\nconst nonCompatibleSpeechRecognitionEventError = 'Sorry the speech recognition API does not support this event';\r\nconst eventListenerNotFoundError = 'Sorry the listener you\\'re trying to remove isn\\'t currently active';\r\nconst noSpeechDetected = 'Sorry no speech detected!';\r\n\r\n// a reference to the bound result handler so it can be removed\r\nlet resultCallback;\r\n\r\nconst defaultNoSupportFunction = () => alert(defaultNoSupportMessage);\r\n\r\nconst isCompatibleSpeechRecognitionEvent = function(speechEvents, evt) {\r\n\treturn Object.keys(speechEvents).indexOf(evt) > -1;\r\n}\r\n\r\n\r\n/*\r\n *\tFires after each result has finished being analysed\r\n *\tSet the autoRestart property to true so it continues to listen\r\n *\totherwise you'll have to manually use the start method to begin listening again\t\r\n */\r\n\r\nexport const onEnd = function() {\r\n\tif(this.autoRestart && this.isListening) {\r\n\t\treturn this.start();\r\n\t}\r\n};\r\n\r\n\r\n/*\r\n *\tCycles through the event listeners stored and adds them to the instance\r\n *\tof the speech recognition constructor used at the heart of Talk To Me\r\n */\r\n\r\nconst addEventListeners = function() {\r\n\r\n\tObject.keys(this.eventListeners).forEach(listener => {\r\n\t\tlet handler = this.eventListeners[listener][0];\r\n\t\tif(handler) {\r\n\t\t\tthis.speech.addEventListener(listener, handler);\r\n\t\t}\t\t\t\r\n\t});\r\n\r\n}\r\n\r\nconst onError = function(e) {\r\n\tif(this.isListening) {\r\n\t\tif(e.error === 'no-speech') {\r\n\t\t\tconsole.warn(noSpeechDetected);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.throwWarning(e.error);\r\n\t\t}\t\r\n\t}\t\r\n}\r\n\r\n\r\n/*\r\n *\tThe ONLY result event listener added to the speech recognition instance\r\n *\tThis is because the event object the native API spits out is heavily modified\r\n *\tand stripped down to just the results and whether it's the last set of results\r\n *\tThis stripped down event object is then passed into each registered result callback\r\n *\twhich is bound so its context is the current instance of Talk To Me\r\n */\r\n\r\nconst onResult = function(evt) {\r\n\r\n\tconst isFinalResult = evt.results[0].isFinal;\r\n\tconst results = [].slice.call(evt.results[0]);\r\n\r\n\tthis.eventListeners.result.forEach((listener, i) => {\r\n\t\tif(i !== 0 && this.isListening) {\r\n\t\t\tlistener.boundCallback({ isFinalResult, results });\r\n\t\t}\r\n\t});\r\n\r\n}\r\n\r\nexport class TalkToMeBase {\r\n\r\n\tconstructor(options = {}) {\r\n\r\n\t\t// get the speech recognition constructor and test for support\r\n\t\tlet { speech, support } = TalkToMeBase.getSpeechRecogniserConstructor();\r\n\t\tthis.support = support;\r\n\r\n\t\tif(this.support) {\r\n\r\n\t\t\t/*\r\n\t\t\t *\tDefault options (optional)\r\n\t\t\t *\tSet against the instance of the speech recognition API\r\n\t\t\t *\tAnd the instance of Talk To Me\r\n\t\t\t */\r\n\r\n\t\t\tlet { numOfAlternativeMatches, language, finalResultsOnly } = options;\r\n\t\t\tfinalResultsOnly = typeof finalResultsOnly === 'undefined' ? false : !finalResultsOnly;\r\n\t\t\t\r\n\t\t\tthis.speech = new speech();\t\t\r\n\t\t\tthis.speech.maxAlternatives = numOfAlternativeMatches || 5;\r\n\t\t\tthis.speech.interimResults = finalResultsOnly;\r\n\t\t\tthis.speech.lang = language || 'en-US';\r\n\r\n\t\t\tthis.isListening = false;\r\n\t\t\tthis.autoRestart = false;\r\n\t\t\tthis.getFirstMatchOnly = true;\r\n\r\n\t\t\t// store a reference to the bound result callback\r\n\t\t\tresultCallback = onResult.bind(this);\r\n\r\n\t\t\t// default event listeners\r\n\t\t\tthis.eventListeners = {\r\n\t\t\t\tstart : [],\r\n\t\t\t\tend : [onEnd.bind(this)],\r\n\t\t\t\taudioend : [],\r\n\t\t\t\taudiostart : [],\r\n\t\t\t\terror : [onError.bind(this)],\r\n\t\t\t\tnomatch : [],\r\n\t\t\t\tresult : [resultCallback],\r\n\t\t\t\tsoundend : [],\r\n\t\t\t\tsoundstart : [],\r\n\t\t\t\tspeechend : [],\r\n\t\t\t\tspeechstart : []\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\taddEventListeners.call(this);\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.throwWarning('Sorry, no speech recognition ability found in this browser.');\r\n\t\t}\r\n\r\n\t}\t\r\n\r\n\t// modify the on no support handler\r\n\tonNoSupport(cb = defaultNoSupportFunction) {\r\n\t\tcb();\r\n\t}\r\n\r\n\r\n\t/*\r\n\t *\tTry / catch will prevent errors thrown if start is called when the\r\n\t *\tspeech recognition API has already started to listen\r\n\t */\r\n\r\n\tstart() {\r\n\t\tthis.isListening = true;\r\n\t\ttry {\r\n\t\t\tthis.speech.start();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch(e) {\r\n\t\t\treturn this.throwWarning(e);\r\n\t\t}\t\r\n\t}\r\n\r\n\tstop() {\r\n\t\tthis.isListening = false;\r\n\t\tthis.speech.abort();\r\n\t}\r\n\r\n\t/*\r\n\t *\tAdd event listeners to the instance of the speech recognition API \r\n\t *\tStores a reference to the callback and the bound callback (binds the instance of Talk To Me to it)\r\n\t *\tNote: It will not allow more than one 'result' handler because of the way Talk To Me\r\n\t *\tmodifies the result event object and passes it into the registered callbacks\r\n\t */\r\n\r\n\ton(evt, callback) {\r\n\t\tif(isCompatibleSpeechRecognitionEvent(this.eventListeners, evt)) {\r\n\t\t\tlet boundCallback = callback.bind(this.speech);\r\n\t\t\tif(evt !== 'result') {\r\n\t\t\t\tthis.speech.addEventListener(evt, boundCallback);\r\n\t\t\t}\t\t\t\t\r\n\t\t\tthis.eventListeners[evt].push({ callback, boundCallback });\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.throwWarning(nonCompatibleSpeechRecognitionEventError);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t *\tRemoves event listeners from the instance of the speech recognition API \r\n\t *\tMatches the callback, not the bound one as externally there is no reference to it\r\n\t *\tThen removes the bound callback counterpart event listener\r\n\t *\r\n\t *\tNote: if the penultimate result event listener is removed, Talk To Me's result listener\r\n\t *\tis also removed, the instance of the speech recognition API is destroyed and a new one created \r\n\t *\tand the event listeners are re-registered\r\n\t *\r\n\t *\tThis is specifically designed for the (additional) Matcher module (it won't affect the base class)\r\n\t *\tThe Matcher module will only ever register one additional result handler \r\n\t *\tand consolidates all searches into a single callback. If it is set to find just the first match \r\n\t *\tit will fire the callback and destroy the instance of the speech recognition API \r\n\t *\tto prevent remaining result events from firing\r\n\t */\r\n\r\n\toff(evt, callback) {\r\n\t\tif(isCompatibleSpeechRecognitionEvent(this.eventListeners, evt)) {\r\n\r\n\t\t\tlet indexOfCallback = this.eventListeners[evt].reduce((ioc, callbacks, i) => {\r\n\t\t\t\tif(callbacks.callback === callback) {\r\n\t\t\t\t\tioc = i;\r\n\t\t\t\t}\r\n\t\t\t\treturn ioc;\r\n\t\t\t}, -1);\r\n\r\n\t\t\tif(indexOfCallback > -1) {\r\n\t\t\t\tif(evt !== 'result') {\r\n\t\t\t\t\tthis.speech.removeEventListener(evt, this.eventListeners[evt][indexOfCallback].boundCallback);\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\tthis.eventListeners[evt].splice(indexOfCallback, 1);\r\n\t\t\t}\t\r\n\t\t\telse {\r\n\t\t\t\treturn this.throwWarning(eventListenerNotFoundError);\r\n\t\t\t}\t\r\n\r\n\t\t\tif(evt === 'result' && this.eventListeners.result.length === 1) {\r\n\t\t\t\t\r\n\t\t\t\tthis.speech.removeEventListener('result', resultCallback);\r\n\t\t\t\tlet { speech } = TalkToMeBase.getSpeechRecogniserConstructor();\r\n\t\t\t\tthis.speech = new speech();\r\n\t\t\t\taddEventListeners.call(this);\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn throwWarning(nonCompatibleSpeechRecognitionEventError);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthrowWarning(msg) {\r\n\t\tconsole.warn(msg);\t\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatic getSpeechRecogniserConstructor() {\r\n\t\tlet speech = window.SpeechRecognition ||\r\n\t\t\twindow.webkitSpeechRecognition ||\r\n\t\t\twindow.mozSpeechRecognition ||\r\n\t\t\twindow.msSpeechRecognition ||\r\n\t\t\twindow.oSpeechRecognition;\r\n\t\treturn { speech, support : !!speech }\r\n\t}\r\n\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./js/talk-to-me-base.js\n **/"],"sourceRoot":""}